use clap::Parser;
use itertools::{EitherOrBoth, Itertools};
use std::path::PathBuf;
use wad::{Lump, Wad};

#[derive(Debug, clap::Parser)]
struct Options {
    /// The input WADs, all generated by Obsidian.
    wads: Vec<PathBuf>,

    /// Set the output WAD path.
    #[clap(short, long)]
    output: PathBuf,
}

#[derive(Debug)]
struct BinaryMap<'wad> {
    things: &'wad Lump,
    linedefs: &'wad Lump,
    sidedefs: &'wad Lump,
    vertexes: &'wad Lump,
    segs: &'wad Lump,
    ssectors: &'wad Lump,
    nodes: &'wad Lump,
    sectors: &'wad Lump,
    reject: Option<&'wad Lump>,
    blockmap: Option<&'wad Lump>,
    behavior: Option<&'wad Lump>,
    scripts: Option<&'wad Lump>,
}

#[derive(Debug)]
enum Map<'wad> {
    Binary(BinaryMap<'wad>),
    Udmf(&'wad Lump),
}

struct MapIterator<'wad> {
    wad: &'wad Wad,
    // 1-32
    last_mapnum: usize,
}

const BINARY_MAP_SEQUENCE: &[&str] = &[
    "THINGS", "LINEDEFS", "SIDEDEFS", "VERTEXES", "SEGS", "SSECTORS", "NODES", "SECTORS",
];

impl<'wad> Iterator for MapIterator<'wad> {
    type Item = Map<'wad>;

    fn next(&mut self) -> Option<Self::Item> {
        let maplump = self
            .wad
            .lump_index
            .get(&format!("MAP{:02}", self.last_mapnum))?;
        let maplump = *maplump;
        'check_binary: {
            let mut lumps = Vec::<&Lump>::new();
            for pair in BINARY_MAP_SEQUENCE
                .iter()
                .copied()
                .zip_longest(self.wad.lumps[maplump + 1..].iter())
            {
                match pair {
                    // ran out of lumps
                    EitherOrBoth::Left(_) => break 'check_binary,
                    // success
                    EitherOrBoth::Right(_) => break,
                    EitherOrBoth::Both(expected_name, lump) => {
                        dbg!(&lump.name);
                        if lump.name != expected_name {
                            // mismatch
                            break 'check_binary;
                        } else {
                            lumps.push(lump);
                        }
                    }
                }
            }
            let mut idx = maplump + 1 + lumps.len();
            let reject = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "REJECT").then(|| {
                    idx += 1;
                    lump
                })
            });
            let blockmap = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "BLOCKMAP").then(|| {
                    idx += 1;
                    lump
                })
            });
            let behavior = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "BEHAVIOR").then(|| {
                    idx += 1;
                    lump
                })
            });
            let scripts = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "SCRIPTS").then(|| {
                    idx += 1;
                    lump
                })
            });
            self.last_mapnum += 1;
            return Some(Map::Binary(BinaryMap {
                things: lumps[0],
                linedefs: lumps[1],
                sidedefs: lumps[2],
                vertexes: lumps[3],
                segs: lumps[4],
                ssectors: lumps[5],
                nodes: lumps[6],
                sectors: lumps[7],
                reject,
                blockmap,
                behavior,
                scripts,
            }));
        }
        // must be UDMF then...
        let textmap = self
            .wad
            .lumps
            .get(maplump + 1)
            .and_then(|lump| (lump.name == "TEXTMAP").then(|| lump))?;
        self.last_mapnum += 1;
        Some(Map::Udmf(textmap))
    }
}

fn get_all_maps(wad: &Wad) -> MapIterator<'_> {
    MapIterator {
        wad,
        last_mapnum: 1,
    }
}

fn main() {
    let opts = Options::parse();
    let wads = opts
        .wads
        .iter()
        .map(|path| Wad::new(path).unwrap())
        .collect_vec();
    let maps = wads
        .iter()
        .map(|wad| get_all_maps(wad))
        .flatten()
        .collect_vec();
}
