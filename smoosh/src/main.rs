use clap::{builder::PossibleValue, Parser, ValueEnum};
use itertools::{EitherOrBoth, Itertools};
use linked_hash_map::LinkedHashMap;
use rand::seq::SliceRandom;
use std::path::PathBuf;
use wad::{Lump, Wad};

#[derive(Debug, Clone, Copy)]
enum Mode {
    Concat,
    Chaos,
    Slog,
}

impl ValueEnum for Mode {
    fn value_variants<'a>() -> &'a [Self] {
        &[Self::Concat, Self::Chaos, Self::Slog]
    }

    fn to_possible_value(&self) -> Option<clap::builder::PossibleValue> {
        Some(match self {
            Self::Concat => PossibleValue::new("concat")
                .help("Simply concatenate each WAD. May result in jarring difficulty drops."),
            Self::Chaos => PossibleValue::new("chaos").help("Full randomization. Fun guaranteed?"),
            Self::Slog => PossibleValue::new("slog")
                .help("Each map is kept close to its original slot. (MAP01, MAP01, MAP02, ...)"),
        })
    }
}

#[derive(Debug, clap::Parser)]
struct Options {
    /// The input WADs, all generated by Obsidian.
    #[clap(required = true)]
    wads: Vec<PathBuf>,

    /// This tool supports several ways to order the maps.
    #[clap(short, long)]
    mode: Mode,
}

#[derive(Debug)]
struct BinaryMap<'wad> {
    things: &'wad Lump,
    linedefs: &'wad Lump,
    sidedefs: &'wad Lump,
    vertexes: &'wad Lump,
    segs: &'wad Lump,
    ssectors: &'wad Lump,
    nodes: &'wad Lump,
    sectors: &'wad Lump,
    reject: Option<&'wad Lump>,
    blockmap: Option<&'wad Lump>,
    behavior: Option<&'wad Lump>,
    scripts: Option<&'wad Lump>,
}

#[derive(Debug)]
enum MapLumps<'wad> {
    Binary(BinaryMap<'wad>),
    Udmf(&'wad Lump),
}

#[derive(Debug)]
struct Map<'wad> {
    orig_slot: usize,
    lumps: MapLumps<'wad>,
}

struct MapIterator<'wad, 'res> {
    wad: &'wad Wad,
    last_idx: usize,
    resource_lumps: &'res mut LinkedHashMap<String, &'wad Lump>,
}

const BINARY_MAP_SEQUENCE: &[&str] = &[
    "THINGS", "LINEDEFS", "SIDEDEFS", "VERTEXES", "SEGS", "SSECTORS", "NODES", "SECTORS",
];

impl<'wad, 'res> Iterator for MapIterator<'wad, 'res> {
    type Item = Map<'wad>;

    fn next(&mut self) -> Option<Self::Item> {
        let mut result = None;
        let mut maplump = self.wad.lumps.get(self.last_idx)?;
        while !maplump.name.starts_with("MAP") {
            self.resource_lumps.insert(maplump.name.clone(), maplump);
            self.last_idx += 1;
            maplump = self.wad.lumps.get(self.last_idx)?;
        }
        let orig_slot = maplump.name[3..].parse::<usize>().unwrap();
        'check_binary: {
            let mut lumps = Vec::<&Lump>::new();
            for pair in BINARY_MAP_SEQUENCE
                .iter()
                .copied()
                .zip_longest(self.wad.lumps[self.last_idx + 1..].iter())
            {
                match pair {
                    // ran out of lumps
                    EitherOrBoth::Left(_) => break 'check_binary,
                    // success
                    EitherOrBoth::Right(_) => break,
                    EitherOrBoth::Both(expected_name, lump) => {
                        if lump.name != expected_name {
                            // mismatch
                            break 'check_binary;
                        } else {
                            lumps.push(lump);
                        }
                    }
                }
            }
            let mut idx = self.last_idx + 1 + lumps.len();
            let reject = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "REJECT").then(|| {
                    idx += 1;
                    lump
                })
            });
            let blockmap = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "BLOCKMAP").then(|| {
                    idx += 1;
                    lump
                })
            });
            let behavior = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "BEHAVIOR").then(|| {
                    idx += 1;
                    lump
                })
            });
            let scripts = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "SCRIPTS").then(|| {
                    idx += 1;
                    lump
                })
            });
            self.last_idx = idx;
            result = Some(Map {
                orig_slot,
                lumps: MapLumps::Binary(BinaryMap {
                    things: lumps[0],
                    linedefs: lumps[1],
                    sidedefs: lumps[2],
                    vertexes: lumps[3],
                    segs: lumps[4],
                    ssectors: lumps[5],
                    nodes: lumps[6],
                    sectors: lumps[7],
                    reject,
                    blockmap,
                    behavior,
                    scripts,
                }),
            });
        }
        if result.is_none() {
            // must be UDMF then...
            if let Some(textmap) = self
                .wad
                .lumps
                .get(self.last_idx + 1)
                .and_then(|lump| (lump.name == "TEXTMAP").then(|| lump))
            {
                // MAP01, TEXTMAP, ENDMAP
                self.last_idx += 3;
                result = Some(Map {
                    orig_slot,
                    lumps: MapLumps::Udmf(textmap),
                });
            }
        }

        if result.is_none() {
            self.resource_lumps.insert(maplump.name.clone(), maplump);
            self.last_idx += 1;
            while self.last_idx < self.wad.lumps.len() {
                let lump = &self.wad.lumps[self.last_idx];
                self.resource_lumps.insert(lump.name.clone(), lump);
                self.last_idx += 1;
            }
        }
        result
    }
}

fn get_all_maps<'wad, 'res>(
    wad: &'wad Wad,
    resource_lumps: &'res mut LinkedHashMap<String, &'wad Lump>,
) -> MapIterator<'wad, 'res> {
    MapIterator {
        wad,
        last_idx: 0,
        resource_lumps,
    }
}

fn main() {
    let opts = Options::parse();
    let wads = opts
        .wads
        .iter()
        .map(|path| Wad::new(path).unwrap())
        .collect_vec();
    let mut resource_lumps = LinkedHashMap::new();
    let mut maps = wads
        .iter()
        .map(|wad| get_all_maps(wad, &mut resource_lumps).collect_vec())
        .flatten()
        .collect_vec();
    let mut out_wad = Wad::new_empty(wads.iter().map(|w| w.was_zip).any(|b| b));
    for lump in resource_lumps.values().copied() {
        out_wad.add_lump(lump.clone());
    }
    match opts.mode {
        Mode::Concat => {} // already in this order
        Mode::Chaos => maps.shuffle(&mut rand::thread_rng()),
        Mode::Slog => maps.sort_by(|m1, m2| m1.orig_slot.cmp(&m2.orig_slot)),
    }
    for (i, map) in maps.into_iter().enumerate() {
        let mapnum = i + 1;
        out_wad.add_lump(Lump {
            name: format!("MAP{:02}", mapnum),
            data: vec![],
        });
        match map.lumps {
            MapLumps::Binary(b) => {
                out_wad.add_lump(b.things.clone());
                out_wad.add_lump(b.linedefs.clone());
                out_wad.add_lump(b.sidedefs.clone());
                out_wad.add_lump(b.vertexes.clone());
                out_wad.add_lump(b.segs.clone());
                out_wad.add_lump(b.ssectors.clone());
                out_wad.add_lump(b.nodes.clone());
                out_wad.add_lump(b.sectors.clone());
                if let Some(reject) = b.reject {
                    out_wad.add_lump(reject.clone());
                }
                if let Some(blockmap) = b.blockmap {
                    out_wad.add_lump(blockmap.clone());
                }
                if let Some(behavior) = b.behavior {
                    out_wad.add_lump(behavior.clone());
                }
                if let Some(scripts) = b.scripts {
                    out_wad.add_lump(scripts.clone());
                }
            }
            MapLumps::Udmf(textmap) => {
                out_wad.add_lump(textmap.clone());
                out_wad.add_lump(Lump {
                    name: String::from("ENDMAP"),
                    data: vec![],
                });
            }
        }
    }
    out_wad
        .write(format!(
            "output.{}",
            if out_wad.was_zip { "pk3" } else { "wad" }
        ))
        .unwrap();
}
