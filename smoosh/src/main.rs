use clap::Parser;
use itertools::{EitherOrBoth, Itertools};
use linked_hash_map::LinkedHashMap;
use std::path::PathBuf;
use wad::{Lump, Wad};

#[derive(Debug, clap::Parser)]
struct Options {
    /// The input WADs, all generated by Obsidian.
    wads: Vec<PathBuf>,
}

#[derive(Debug)]
struct BinaryMap<'wad> {
    things: &'wad Lump,
    linedefs: &'wad Lump,
    sidedefs: &'wad Lump,
    vertexes: &'wad Lump,
    segs: &'wad Lump,
    ssectors: &'wad Lump,
    nodes: &'wad Lump,
    sectors: &'wad Lump,
    reject: Option<&'wad Lump>,
    blockmap: Option<&'wad Lump>,
    behavior: Option<&'wad Lump>,
    scripts: Option<&'wad Lump>,
}

#[derive(Debug)]
enum Map<'wad> {
    Binary(BinaryMap<'wad>),
    Udmf(&'wad Lump),
}

struct MapIterator<'wad, 'res> {
    wad: &'wad Wad,
    last_idx: usize,
    resource_lumps: &'res mut LinkedHashMap<String, &'wad Lump>,
}

const BINARY_MAP_SEQUENCE: &[&str] = &[
    "THINGS", "LINEDEFS", "SIDEDEFS", "VERTEXES", "SEGS", "SSECTORS", "NODES", "SECTORS",
];

impl<'wad, 'res> Iterator for MapIterator<'wad, 'res> {
    type Item = Map<'wad>;

    fn next(&mut self) -> Option<Self::Item> {
        let mut result = None;
        let mut maplump = self.wad.lumps.get(self.last_idx)?;
        while !maplump.name.starts_with("MAP") {
            self.resource_lumps.insert(maplump.name.clone(), maplump);
            self.last_idx += 1;
            maplump = self.wad.lumps.get(self.last_idx)?;
        }
        'check_binary: {
            let mut lumps = Vec::<&Lump>::new();
            for pair in BINARY_MAP_SEQUENCE
                .iter()
                .copied()
                .zip_longest(self.wad.lumps[self.last_idx + 1..].iter())
            {
                match pair {
                    // ran out of lumps
                    EitherOrBoth::Left(_) => break 'check_binary,
                    // success
                    EitherOrBoth::Right(_) => break,
                    EitherOrBoth::Both(expected_name, lump) => {
                        if lump.name != expected_name {
                            // mismatch
                            break 'check_binary;
                        } else {
                            lumps.push(lump);
                        }
                    }
                }
            }
            let mut idx = self.last_idx + 1 + lumps.len();
            let reject = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "REJECT").then(|| {
                    idx += 1;
                    lump
                })
            });
            let blockmap = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "BLOCKMAP").then(|| {
                    idx += 1;
                    lump
                })
            });
            let behavior = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "BEHAVIOR").then(|| {
                    idx += 1;
                    lump
                })
            });
            let scripts = self.wad.lumps.get(idx).and_then(|lump| {
                (lump.name == "SCRIPTS").then(|| {
                    idx += 1;
                    lump
                })
            });
            self.last_idx = idx;
            result = Some(Map::Binary(BinaryMap {
                things: lumps[0],
                linedefs: lumps[1],
                sidedefs: lumps[2],
                vertexes: lumps[3],
                segs: lumps[4],
                ssectors: lumps[5],
                nodes: lumps[6],
                sectors: lumps[7],
                reject,
                blockmap,
                behavior,
                scripts,
            }));
        }
        // must be UDMF then...
        if let Some(textmap) = self
            .wad
            .lumps
            .get(self.last_idx + 1)
            .and_then(|lump| (lump.name == "TEXTMAP").then(|| lump))
        {
            // MAP01, TEXTMAP, ENDMAP
            self.last_idx += 3;
            result = Some(Map::Udmf(textmap));
        }

        if result.is_none() {
            self.resource_lumps.insert(maplump.name.clone(), maplump);
            self.last_idx += 1;
        }
        result
    }
}

fn get_all_maps<'wad, 'res>(
    wad: &'wad Wad,
    resource_lumps: &'res mut LinkedHashMap<String, &'wad Lump>,
) -> MapIterator<'wad, 'res> {
    MapIterator {
        wad,
        last_idx: 0,
        resource_lumps,
    }
}

fn main() {
    let opts = Options::parse();
    let wads = opts
        .wads
        .iter()
        .map(|path| Wad::new(path).unwrap())
        .collect_vec();
    let mut resource_lumps = LinkedHashMap::new();
    let maps = wads
        .iter()
        .map(|wad| get_all_maps(wad, &mut resource_lumps).collect_vec())
        .flatten()
        .collect_vec();
    for lump in resource_lumps.keys() {
        dbg!(lump);
    }
}
